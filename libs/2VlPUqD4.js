const t=t=>Array.isArray(t),e=(t,n)=>t===n||null!==t&&null!==n&&"object"==typeof t&&"object"==typeof n&&Object.keys(t).length===Object.keys(n).length&&Object.entries(t).every((([t,r])=>e(r,n[t])));function n(t){return(...e)=>{const n=e.map((t=>p(t))),r=n[0],o=n[1];return 1===n.length?e=>t(r(e)):2===n.length?e=>t(r(e),o(e)):e=>t(...n.map((t=>t(e))))}}const r={boolean:0,number:1,string:2},o=(t,e)=>typeof t==typeof e&&typeof t in r&&t>e,s=(t,e)=>typeof t==typeof e&&typeof t in r&&t<e,c={pipe:(...t)=>{const e=t.map((t=>p(t)));return t=>e.reduce(((t,e)=>e(t)),t)},object:t=>{const e=Object.keys(t).map((e=>[e,p(t[e])]));return t=>{const n={};for(const[r,o]of e)n[r]=o(t);return n}},array:(...t)=>{const e=t.map((t=>p(t)));return t=>e.map((e=>e(t)))},get:(...t)=>{if(0===t.length)return t=>t??null;if(1===t.length){const e=t[0];return t=>(null==t?void 0:t[e])??null}return e=>{let n=e;for(const r of t)n=null==n?void 0:n[r];return n??null}},map:t=>{const e=p(t);return t=>t.map(e)},mapObject:t=>{const e=p(t);return t=>{const n={};for(const r of Object.keys(t)){const o=e({key:r,value:t[r]});n[o.key]=o.value}return n}},mapKeys:t=>{const e=p(t);return t=>{const n={};for(const r of Object.keys(t)){n[e(r)]=t[r]}return n}},mapValues:t=>{const e=p(t);return t=>{const n={};for(const r of Object.keys(t))n[r]=e(t[r]);return n}},filter:t=>{const e=p(t);return t=>t.filter((t=>u(e(t))))},sort:(t=["get"],e)=>{const n=p(t),o="desc"===e?-1:1;function s(t,e){const s=n(t),c=n(e);if(typeof s!=typeof c){const t=r[typeof s]??3,e=r[typeof c]??3;return t>e?o:t<e?-o:0}return typeof s in r?s>c?o:s<c?-o:0:0}return t=>t.slice().sort(s)},reverse:()=>t=>t.toReversed(),pick:(...e)=>{const n=e.map((([t,...e])=>[e[e.length-1],c.get(...e)])),r=(t,e)=>{const n={};for(const[r,o]of e)n[r]=o(t);return n};return e=>t(e)?e.map((t=>r(t,n))):r(e,n)},groupBy:t=>{const e=p(t);return t=>{const n={};for(const r of t){const t=e(r);n[t]?n[t].push(r):n[t]=[r]}return n}},keyBy:t=>{const e=p(t);return t=>{const n={};for(const r of t){const t=e(r);t in n||(n[t]=r)}return n}},flatten:()=>t=>t.flat(),join:(t="")=>e=>e.join(t),split:n(((t,e)=>void 0!==e?t.split(e):t.trim().split(/\s+/))),substring:n(((t,e,n)=>t.slice(Math.max(e,0),n))),uniq:()=>t=>{const n=[];for(const r of t)-1===n.findIndex((t=>e(t,r)))&&n.push(r);return n},uniqBy:t=>e=>Object.values(c.keyBy(t)(e)),limit:t=>e=>e.slice(0,Math.max(t,0)),size:()=>t=>t.length,keys:()=>Object.keys,values:()=>Object.values,prod:()=>t=>i(t,((t,e)=>t*e)),sum:()=>e=>t(e)?e.reduce(((t,e)=>t+e),0):l(),average:()=>e=>t(e)?e.length>0?e.reduce(((t,e)=>t+e))/e.length:null:l(),min:()=>t=>i(t,((t,e)=>Math.min(t,e))),max:()=>t=>i(t,((t,e)=>Math.max(t,e))),and:n(((...t)=>i(t,((t,e)=>!(!t||!e))))),or:n(((...t)=>i(t,((t,e)=>!(!t&&!e))))),not:n((t=>!t)),exists:t=>{const e=t.slice(1),n=e.pop(),r=c.get(...e);return t=>{const e=r(t);return!!e&&Object.hasOwnProperty.call(e,n)}},if:(t,e,n)=>{const r=p(t),o=p(e),s=p(n);return t=>u(r(t))?o(t):s(t)},in:(t,n)=>{const r=p(t),o=p(n);return t=>{const n=r(t);return-1!==o(t).findIndex((t=>e(t,n)))}},"not in":(t,e)=>{const n=c.in(t,e);return t=>!n(t)},regex:(t,e,n)=>{const r=new RegExp(e,n),o=p(t);return t=>r.test(o(t))},eq:n(e),gt:n(o),gte:n(((t,n)=>e(t,n)||o(t,n))),lt:n(s),lte:n(((t,n)=>e(t,n)||s(t,n))),ne:n(((t,n)=>!e(t,n))),add:n(((t,e)=>t+e)),subtract:n(((t,e)=>t-e)),multiply:n(((t,e)=>t*e)),divide:n(((t,e)=>t/e)),mod:n(((t,e)=>t%e)),pow:n(((t,e)=>t**e)),abs:n(Math.abs),round:n(((t,e=0)=>+`${Math.round(+`${t}e${e}`)}e${-e}`)),number:n((t=>{const e=Number(t);return Number.isNaN(Number(t))?null:e})),string:n(String)},u=t=>null!==t&&0!==t&&!1!==t,i=(e,n)=>(t(e)||l(),0===e.length?null:e.reduce(n)),l=()=>{a("Array expected")},a=t=>{throw new TypeError(t)},f=[];function p(e,n){f.unshift({...c,...f[0],...null==n?void 0:n.functions});try{const n=t(e)?function(t,e){const[n,...r]=t,o=e[n];return o||a(`Unknown function '${n}'`),o(...r)}(e,f[0]):(e=>null!==e&&"object"==typeof e&&!t(e))(e)?a(`Function notation ["object", {...}] expected but got ${JSON.stringify(e)}`):()=>e;return t=>{try{return n(t)}catch(r){throw r.jsonquery=[{data:t,query:e},...r.jsonquery??[]],r}}}finally{f.shift()}}const d=[{pow:"^"},{multiply:"*",divide:"/",mod:"%"},{add:"+",subtract:"-"},{gt:">",gte:">=",lt:"<",lte:"<=",in:"in","not in":"not in"},{eq:"==",ne:"!="},{and:"and"},{or:"or"},{pipe:"|"}],y=["|","and","or"],g=["|","and","or","*","/","%","+","-"];function h(t,{name:e,op:n,at:r,after:o,before:s}){if(r)return t.map((t=>Object.values(t).includes(r)?{...t,[e]:n}:t));const c=o??s,u=t.findIndex((t=>Object.values(t).includes(c)));if(-1!==u)return t.toSpliced(u+(o?1:0),0,{[e]:n});throw new Error("Invalid custom operator")}const b=/^[a-zA-Z_$][a-zA-Z\d_$]*/,m=/^"(?:[^"\\]|\\.)*"/,j=/^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/,v=/^(0|[1-9][0-9]*)/,O=/^(true|false|null)/,x=/^[ \n\t\r]+/;function k(e,n){const r=(null==n?void 0:n.operators)??[],o=function(e,n){if(!t(n))throw new Error("Invalid custom operators");return n.reduce(h,e)}(d,r),s=Object.assign({},...o),c=y.concat(r.filter((t=>t.vararg)).map((t=>t.op))),u=g.concat(r.filter((t=>t.leftAssociative)).map((t=>t.op))),i=(t=o.length-1)=>{const n=o[t];if(!n)return a();const r="("===e[B];let f=i(t-1);for(;;){M();const e=B,o=l(n);if(!o)break;const a=i(t-1),p=o===f[0]&&!r;if(p&&!u.includes(s[o])){B=e;break}f=p&&c.includes(s[o])?[...f,a]:[o,f,a]}return f},l=t=>{const n=Object.keys(t).sort(((t,e)=>e.length-t.length));for(const r of n){const n=t[r];if(e.substring(B,B+n.length)===n)return B+=n.length,M(),r}},a=()=>{if(M(),"("===e[B]){B++;const t=i();return I(")"),t}return f()},f=()=>{if("."===e[B]){const t=[];for(;"."===e[B];)B++,t.push($()??N()??S()??J("Property expected"));return["get",...t]}return p()},p=()=>{const t=B,n=N();if(M(),!n||"("!==e[B])return B=t,k();B++,M();const r=")"!==e[B]?[i()]:[];for(;B<e.length&&")"!==e[B];)M(),I(","),r.push(i());return I(")"),[n,...r]},k=()=>{if("{"===e[B]){B++,M();const t={};let n=!0;for(;B<e.length&&"}"!==e[B];){n?n=!1:(I(","),M());const e=$()??N()??S()??J("Key expected");M(),I(":"),t[e]=i()}return I("}"),["object",t]}return w()},w=()=>{if("["===e[B]){B++,M();const t=[];let n=!0;for(;B<e.length&&"]"!==e[B];)n?n=!1:(I(","),M()),t.push(i());return I("]"),["array",...t]}return $()??q()??A()},$=()=>E(m,JSON.parse),N=()=>E(b,(t=>t)),q=()=>E(j,JSON.parse),S=()=>E(v,JSON.parse),A=()=>{const t=E(O,JSON.parse);if(void 0!==t)return t;J("Value expected")},E=(t,n)=>{const r=e.substring(B).match(t);if(r)return B+=r[0].length,n(r[0])},M=()=>E(x,(t=>t)),I=t=>{e[B]!==t&&J(`Character '${t}' expected`),B++},J=(t,e=B)=>{throw new SyntaxError(`${t} (pos: ${e})`)};let B=0;const z=i();return M(),B<e.length&&J(`Unexpected part '${e.substring(B)}'`),z}function w(t,e,n){return p((t=>"string"==typeof t)(e)?k(e,n):e,n)(t)}export{n as buildFunction,p as compile,w as jsonquery,k as parse};
